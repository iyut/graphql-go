package main

import (
	"context"
	"encoding/json"
	"fmt"

	graphql "github.com/graph-gophers/graphql-go"
)

// Define a schema string:
const schemaString = `
	# Define what the schema is capable of:
	schema {
		query: Query
	}
	# Define what the queries are capable of:
	type Query {
		# Generic greeting, e.g. "Hello, world!":
		greet: String!
		# Customized greeting, e.g. "Hello, Johan!":
		greetPerson(person: String!): String!
		# More customized greeting, e.g. "Good morning, Johan!":
		greetPersonTimeOfDay(person: String!, timeOfDay: TimeOfDay!): String!
	}
	# Enumerate times of day:
	enum TimeOfDay {
		MORNING
		AFTERNOON
		EVENING
	}
`

// Define a root resolver to hook queries onto:
type RootResolver struct{}

// Define the greet: String! query:
func (*RootResolver) Greet() string {

	return "Hello World!"
}

func (*RootResolver) GreetPerson(args struct{ Person string }) string {
	return fmt.Sprintf("Hello, %s!", args.Person)
}

type PersonTimeOfDayArgs struct {
	Person    string
	TimeOfDay string
}

var TimesOfDay = map[string]string{
	"MORNING":   "Good morning",
	"AFTERNOON": "Good afternoon",
	"EVENING":   "Good evening",
}

func (*RootResolver) GreetPersonTimeOfDay(ctx context.Context, args PersonTimeOfDayArgs) string {

	timeOfDay, ok := TimesOfDay[args.TimeOfDay]
	if !ok {
		timeOfDay = "Go to bed"
	}

	return fmt.Sprintf("%s %s!", timeOfDay, args.Person)
}

// There are two ways we can define a schema:
//
// - graphql.MustParseSchema(...) *graphql.Schema // Panics on error.
// - graphql.ParseSchema(...) (*graphql.Schema, error)
//
// Define a schema:
var Schema = graphql.MustParseSchema(schemaString, &RootResolver{})

func main() {

	ctx := context.Background()

	///// EXAMPLE 1
	query := `{
		greet	
	}`
	//
	// You can also use these syntax forms if you prefer:
	//
	// descriptiveQuery := `query {
	// 	greet
	// }`
	//
	// moreDescriptiveQuery := `query Greet {
	// 	greet
	// }`
	resp := Schema.Exec(ctx, query, "", nil)
	json0, err := json.MarshalIndent(resp, "", "\t")
	if err != nil {
		panic(err)
	}
	fmt.Println(string(json0))

	///// EXAMPLE 2
	type ClientQuery struct {
		OpName    string                 // Operation name.
		Query     string                 // Query string.
		Variables map[string]interface{} // Query variables (untyped).
	}

	q1 := ClientQuery{
		OpName: "Greet",
		Query: `query Greet {
			greet	
		}`,
		Variables: nil,
	}

	resp1 := Schema.Exec(ctx, q1.Query, q1.OpName, q1.Variables)
	json1, err := json.MarshalIndent(resp1, "", "\t")
	if err != nil {
		panic(err)
	}

	fmt.Println(string(json1))

	///// EXAMPLE 3
	q2 := ClientQuery{
		OpName: "GreetPerson",
		Query: `query GreetPerson($person: String!) {
			greetPerson(person: $person)
		}`,
		Variables: map[string]interface{}{
			"person": "Luthfi",
		},
	}

	resp2 := Schema.Exec(ctx, q2.Query, q2.OpName, q2.Variables)
	json2, err := json.MarshalIndent(resp2, "", "\t")
	if err != nil {
		panic(err)
	}

	fmt.Println(string(json2))

	///// EXAMPLE 4
	q3 := ClientQuery{
		OpName: "GreetPersonTimeOfDay",
		Query: `query GreetPersonTimeOfDay($person: String!, $timeOfDay: TimeOfDay!) {
			greetPersonTimeOfDay( person: $person, timeOfDay: $timeOfDay)
		}`,
		Variables: map[string]interface{}{
			"person":    "Luthfi",
			"timeOfDay": "MORNING",
		},
	}

	resp3 := Schema.Exec(ctx, q3.Query, q3.OpName, q3.Variables)
	json3, err := json.MarshalIndent(resp3, "", "\t")
	if err != nil {
		panic(err)
	}

	fmt.Println(string(json3))
}
